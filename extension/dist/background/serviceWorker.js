chrome.runtime.onInstalled.addListener(()=>{console.log("ThreadFinder service worker installed")});chrome.runtime.onStartup?.addListener(()=>{console.log("ThreadFinder service worker started")});try{chrome.runtime.onInstalled.addListener(()=>{chrome.contextMenus&&chrome.contextMenus.create({id:"threadfinder-search",title:'Search discussions for "%s"',contexts:["selection"]})}),chrome.contextMenus?.onClicked.addListener((e,i)=>{if(e.menuItemId==="threadfinder-search"&&e.selectionText){const r=e.selectionText.trim();if(!r)return;i?.id&&chrome.tabs.sendMessage(i.id,{type:"threadfinder:search",term:r},void 0,()=>{chrome.runtime.lastError})}})}catch(e){console.warn("Context menus not available:",e)}chrome.runtime.onMessage.addListener((e,i,r)=>e&&e.type==="threadfinder:fetchReddit"&&typeof e.term=="string"?((async()=>{try{const t=await I(e.term);r({ok:!0,items:t})}catch(t){console.error("Reddit fetch failed:",t),r({ok:!1,error:String(t)})}})(),!0):e&&e.type==="threadfinder:gemini"&&typeof e.prompt=="string"?((async()=>{try{const t=await G(e.prompt,e.context||"");r({text:t})}catch(t){console.error("Gemini API error:",t),r({error:t.message||"Failed to get response from Gemini",details:t.details})}})(),!0):!1);let w=null;function y(e,i,r=6e4){return new Promise((t,a)=>{const c=new AbortController,f=setTimeout(()=>c.abort(),r);fetch(e,{...i,signal:c.signal}).then(d=>{clearTimeout(f),t(d)}).catch(d=>{clearTimeout(f),d?.name==="AbortError"?a(new Error("Gemini request timed out")):a(d)})})}function x(e){try{const i=Array.isArray(e?.candidates)?e.candidates:[];for(const r of i){const a=(Array.isArray(r?.content?.parts)?r.content.parts:[]).map(c=>typeof c?.text=="string"?c.text:"").filter(c=>c);if(a.length)return a.join(`
`)}return""}catch{return""}}async function G(e,i=""){const t=(await chrome.storage.sync.get("GEMINI_API_KEY")).GEMINI_API_KEY;if(!t)throw new Error("Gemini API key not found. Please set it in the extension options.");const a={systemInstruction:{role:"system",parts:[{text:"Provide a concise, plain-text answer. Do not include reasoning steps. Limit to a short paragraph."}]},contents:[{role:"user",parts:[{text:`${e}

Context:
${i||"No additional context provided."}`}]}],generationConfig:{temperature:.4,topK:40,topP:.95,maxOutputTokens:1024,responseMimeType:"text/plain"}},c=["gemini-2.5-pro","gemini-1.5-flash","gemini-1.5-pro","gemini-1.0-pro","gemini-pro"],f=["v1beta","v1"];try{await y("https://generativelanguage.googleapis.com/v1beta/models",{method:"GET",headers:{"x-goog-api-key":t}},5e3)}catch(n){const o=new Error("Unable to reach generativelanguage.googleapis.com (preflight). Possible network/VPN/firewall/adblock issue or invalid API key.");throw o.details={stage:"preflight_listmodels_v1beta",original:String(n?.message||n)},o}let d=null;{const n="v1beta",o="gemini-1.5-flash",g=`https://generativelanguage.googleapis.com/${n}/models/${o}:generateContent`;try{console.log("[Gemini] try",{base:n,model:o}),console.time(`[Gemini] ${n}/${o}`);const s=await y(g,{method:"POST",headers:{"Content-Type":"application/json","x-goog-api-key":t},body:JSON.stringify(a)},6e4);if(console.timeEnd(`[Gemini] ${n}/${o}`),s.ok){const m=await s.json(),h=x(m);if(h)return w={base:n,model:o},h;const p=new Error("Gemini returned no text (possibly safety blocked)");throw p.details=m,p}}catch(s){console.timeEnd(`[Gemini] ${n}/${o}`),d=s}}if(w){const{base:n,model:o}=w,g=`https://generativelanguage.googleapis.com/${n}/models/${o}:generateContent`;try{const s=await y(g,{method:"POST",headers:{"Content-Type":"application/json","x-goog-api-key":t},body:JSON.stringify(a)},4e4);if(s.ok){const m=await s.json(),h=x(m);if(h)return h;const p=new Error("Gemini returned no text (possibly safety blocked)");throw p.details=m,p}}catch{}}const l=["gemini-2.5-pro",...c.filter(n=>n!=="gemini-2.5-pro")];for(const n of f)for(const o of l){const g=`https://generativelanguage.googleapis.com/${n}/models/${o}:generateContent`;try{console.log("[Gemini] try",{base:n,model:o}),console.time(`[Gemini] ${n}/${o}`);let s=null,m=null;for(let $=0;$<2;$++)try{s=await y(g,{method:"POST",headers:{"Content-Type":"application/json","x-goog-api-key":t},body:JSON.stringify(a)},6e4);break}catch(b){m=b,await E(250)}if(!s)throw m||new Error("No response");if(!s.ok){const $=await s.json().catch(()=>({})),b=new Error(`API error (${o} on ${n}): ${s.status} ${s.statusText}`);b.details={...$,tried:{base:n,model:o}},d=b,console.timeEnd(`[Gemini] ${n}/${o}`);continue}const h=await s.json(),p=x(h);if(p)return console.timeEnd(`[Gemini] ${n}/${o}`),w={base:n,model:o},p;const k=new Error(`Gemini returned no text from ${o} on ${n} (possibly safety blocked)`);k.details=h,d=k}catch(s){console.timeEnd(`[Gemini] ${n}/${o}`),d=s}}const u=await T(t);if(u){w=u;const n=`https://generativelanguage.googleapis.com/${u.base}/models/${u.model}:generateContent`,o=await y(n,{method:"POST",headers:{"Content-Type":"application/json","x-goog-api-key":t},body:JSON.stringify(a)},6e4);if(!o.ok){const h=await o.json().catch(()=>({})),p=new Error(`API error (${u.model} on ${u.base}): ${o.status} ${o.statusText}`);throw p.details={...h,tried:u},p}const g=await o.json(),s=x(g);if(s)return s;const m=new Error("Empty response from discovered Gemini model (possibly safety blocked)");throw m.details=g,m}throw d||new Error("Gemini request failed")}async function T(e){const i=["v1","v1beta"];for(const r of i)try{const t=`https://generativelanguage.googleapis.com/${r}/models`,a=await fetch(t,{method:"GET",headers:{"x-goog-api-key":e}});if(!a.ok)continue;const d=((await a.json())?.models||[]).find(l=>Array.isArray(l.supportedGenerationMethods)&&l.supportedGenerationMethods.includes("generateContent"));if(d?.name){const l=String(d.name).split("/"),u=l[l.length-1];return{base:r,model:u}}}catch{}return null}const v=new Map,C=120*1e3;async function I(e){const i=e.trim().toLowerCase(),r=v.get(i),t=Date.now();if(r&&t-r.ts<C)return r.rows;const a=await P(e);return v.set(i,{ts:t,rows:a}),a}async function P(e){const i=[`https://api.reddit.com/search.json?q=${encodeURIComponent(e)}&limit=5&sort=relevance`,`https://www.reddit.com/search.json?q=${encodeURIComponent(e)}&limit=5&sort=relevance&raw_json=1`];let r=null;for(let t=0;t<i.length;t++){const a=i[t];try{const c=await fetch(a,{cache:"no-store"});if(!c.ok){r=new Error(`status ${c.status}`),await E(150);continue}return((await c.json())?.data?.children||[]).map(l=>l.data).map(l=>({title:l.title,url:`https://www.reddit.com${l.permalink}`,subreddit:l.subreddit}))}catch(c){r=c,await E(150)}}throw r||new Error("Reddit fetch failed")}function E(e){return new Promise(i=>setTimeout(i,e))}
